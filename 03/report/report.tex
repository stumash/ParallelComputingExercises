\documentclass[11pt, letterpaper]{article}

\title{Assignment 3}
\author{
    Stuart Mashaal\\
    \texttt{260639962}
    \and
    Oliver Tse Sakkwun\\
    \texttt{260604362}
}
\date{Due: December 4, 2018}

\usepackage[utf8]{inputenc} % utf-8 file encoding
\usepackage[margin=0.75in]{geometry} % widen page margins
\usepackage{minted} % code samples
\setminted{fontsize=\small}
\usepackage{graphicx} % use external images
\graphicspath{ {images/} } % folder of images
\setlength\parindent{0pt} % no paragraph indent
\usepackage{amsmath} % math tools
\usepackage{enumitem} % convenient list formatting

\newcommand{\code}[1] { \mintinline{python3}{#1} }

\begin{document}

\begin{titlepage}
    \maketitle
    \thispagestyle{empty}
    \setcounter{page}{0}
\end{titlepage}

\section*{Question 1}
\label{sec:question_1}

\subsection*{1.1}
\label{sub:1_1}

\subsection*{1.2}
\label{sub:1_2}

\subsection*{1.3}
\label{sub:1_3}

\subsection*{1.4}
\label{sub:1_4}

\subsection*{1.5}
\label{sub:1_5}

\section*{Question 2}
\subsection*{2.1}
See in code
\subsection*{2.2}
The contains method scans the list to find the pair of nodes (pred,curr) reachable from head such that
pred.next == curr,pred.key < key and curr.key >= key.The traversal uses hand-over-hand locking.
\begin{itemize}
\item Item is not in the list \\
When curr.key == key is false that is curr.key > key. From the sortedness
invariant of the list, pred.next == curr, and pred.key < key we conclude that item cannot be in the
set.

 \item Item is in the list \\
When curr.key == key is true, then from the uniqueness of keys that curr.item = item. Hence, item is in the set.
\end{itemize}


\section*{Question 3}
\subsection*{3.1}
Working on that
\subsection*{3.2}
The difficulty is to define the criteria where the indexes are valid to be read or written. We had to add two more atomic variables: the first representing how many elements can still be inserted; the second represents the valid indices for reading.

\newpage
\section*{Question 4}

\subsection*{4.3}

\subsection*{4.4}
First, the implementation breaks up the matrix-by-vector multiplication into its various vector-vector dot products. It does this by breaking the matrix into two halves, then halving again and again until it reaches a half that consists of only one row. At this point, it initiates a dot product on that row.\\

Note that the number of \textit{work nodes} of this step is therefore $\Theta(2N)$, the number of nodes in a fully-balanced binary tree containing $N$ leaves.\\

Each ``leaf'' of this binary tree is a dot product to be computed. The dot product is broken up into the sum of two \textit{sub-dot-products}, halving all the way down as before. At the bottom, there is a single two-integer multiplication to do. Once again, this is $\Theta(2N)$ work nodes.\\

Because $2N \cdot 2N \in \Theta(N^2)$, the implementation achieves work $\Theta(N^2)$.\\

Also note that the longest possible path through this graph is all the way to bottom of one tree, then another, then back up both of them. That's $\Theta(4 \cdot log_2(N)) \in \Theta(log_2(N))$, so the implementation meets both the \textit{work} and \textit{critical path} requirements.\\

As for the parallelism,

\end{document}
